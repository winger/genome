%-*- coding: cp1251 -*-
\chapter{Разработанные алгоритмы}
\label{chapter3}

\section{Граф де Брейна}

Графом де Брейна $k$-ого порядка называют ориентированный граф, в котором вершинам соответствуют строки длины $k$,
а ребрам~--- строки длины $k+1$, причем ребра идут из вершины, соответствующей префиксу строки ребра, в вершину,
соответствующую суффиксу \cite{debrujin}.

\begin{figure}[h]
\center{
\includegraphics{pic/debrujin.svg.eps}
}
\caption{Пример графа де Брейна.}
\label{debrujin1}
\end{figure}

Из определения следует что для любого ребра $(u,v)$ суффикс $u$ длины $k-1$ совпадает с префиксом $v$ длины $k-1$.
Ясно, что любому пути в графе соответствует строка, составленная из перекрывающихся строк в вершинах. К примеру
в графе на рис.~\ref{debrujin1} пути из вершины ACAGT в вершину AGTTCC соответствует строка ACAGTTCC.

\section{Алгоритм восстановления цельных фрагментов по известным концам и длине}

Будем решать следущую задачу: по набору пар чтений ${(u_i, v_i)}$ (каждое чтение длинной $k$) и длине исходного
фрагмента $m$ восстановить набор исходных фрагментов.

\begin{figure}[h]
\center{
\includegraphics{pic/general.svg.eps}
}
\caption{Исходные данные.}
\label{general1}
\end{figure}

\subsection{Описание общего алгоритма}

Построим по строкам $u_i, v_i$ граф де Брейна $G$ (то есть граф де Брейна, в котором вершины соответствуют данным
строкам и проведены все возможные ребра). Каждой паре строк $(u_i, v_i)$ соответствует фрагмент исходной
последовательности $x_i$ длиной $m$. Рассмотрим все подстроки $x_i$ длиной $k$: $y_i^j=x_i[j \twodots j+k-1]$, причем 
$y_i^j=u_i$ и $y_i^{m-k}=v_i$. Предположим что покрытие достаточно чтобы каждая подстрока исходной строки была
прочитана хотя бы раз без ошибок. Тогда все $y_i^j$ будут встречаться в качестве вершин $G$. Более того, между
$y_i^j$ и $y_i^{j+1}$ в $G$ будет ребро, соответствующее строке $x_i[j \twodots j+k]$. Таким образом, в $G$ есть
путь из $y_i^1 = u_i$ в $y_i^{m-k} = v_i$ длиной $m-k$, соответсвующий строке $x_i$ и наша задача сводится
к поиску в графе $G$ пути между двумя вершинами заданной длины.

Рассмотрим следующий алгоритм:

\begin{algorithm}
\caption{\proc{Walk}}
\begin{codebox}
\Procname{$\proc{Walk}(G, u, v, \id{foundPaths})$}
\li \Return $\proc{Recursive-Walk}(G, \attrib{G}{vertices}[u], \attrib{G}{vertices}[v], 0, u, \id{foundPaths})$
\end{codebox}
\begin{codebox}
\Procname{$\proc{Recursive-Walk}(G, u, v, \id{depth}, \id{pathString}, \id{foundPaths})$}
\li \If $\id{depth} > \const{maxDepth}$
\li \Then
      \Comment Отсечение перебора при превышении максимальной длины
\li   \Return
    \End
\li \If $u \isequal v$ and $\id{depth} \geqslant \const{minDepth}$
\li \Then
      \Comment Найден путь
\li   \attribii{foundPaths}{add}(\id{pathString})
    \End
\li \For $(u, u') \in \attrib{G}{edges}$
\li   \Do
      \Comment перебираем очередное ребро в пути
\li   $\id{newPathString} \gets \id{pathString} + \attribe{u}{u'}{symbol}$
\li   \Comment аттрибут \id{symbol} ребра $(u, v)$ содержит символ $c$
\li   \Comment такой, что $(u + c)[2 \twodots \attrib{u}{length}] \isequal v$
\li   $\proc{Recursive-Walk}(G, u', v, \id{depth} + 1, \id{newPathString}, \id{foundPaths})$
      \End
\end{codebox}
\end{algorithm}

Данный алгоритм находит все строки, соответствующие путям в графе $G$ из вершины $u$ в вершину $v$ и
имеющие длину от \const{minDepth} до \const{maxDepth}.
Процедура \proc{Recursive-Walk} реализует рекурсивный обход графа. В процессе работы поддерживаются следующие
инварианты: 
\begin{itemize}
\item \id{depth} содержит длину текущего рассматриваемого пути.
\item \id{pathString} содержит прочтение текущего рассматриваемого пути.
\end{itemize}
Когда текущая длина пути превышает \const{maxDepth}, поиск обрывается.

Получим эмпирическую оценку сложности алгоритма. Будем исходить из предположения что граф $G$
случаен и средняя степень вершины в нем $d$. Тогда вызовов \proc{Recursive-Walk} с
$\id{depth} \isequal 0$ будет $1 = d^0$, с $\id{depth} \isequal 1$ их будет $d^1$, и т.д.
$\id{depth} \isequal \const{maxDepth}$ их будет $d^{\const{maxDepth}}$. Таким образом, всего вызовов будет
$\sum_{i=0}^{\const{maxDepth}}d^i=\frac{d^{\const{maxDepth}+1}-1}{d-1}=O(d^{\const{maxDepth}})$

%картинко

\subsection{Meet-in-the-Middle вариант реализации}

Для ускорения алгоритма 1 можно применить подход Meet-in-the-Middle.

Рассмотрим алгоритм 2. Он работает следующем образом: для всех вершин графа
находятся пути из начальной вершины длиной не более $\lceil \frac{\const{maxDepth}}{2} \rceil$ и
пути в конечную вершину длиной не более $\lfloor \frac{\const{maxDepth}}{2} \rfloor$. После этого
в каждой посещенной вершине мы конкатенируем все возможные префиксы и суффиксы пути нужной длины.

Цикл в строках 5-7 процедуры \proc{Walk-MitM} можно реализовать за $O(\const{maxDist} \cdot |\id{foundPaths}|)$
(каждый конечный путь рассматривается максимум \const{maxDist} раз). Вызовы функций не сильно отличаются
от рекурсивного обходчика в алгоритме 1 и выполняются за $O(d^{\lceil \frac{\const{maxDist}}{2} \rceil})$.
Таким образом, в целом алгоритм выполняется за $O(d^{\lceil \frac{\const{maxDist}}{2} \rceil} + \const{maxDist} \cdot |\id{foundPaths}|)$

\begin{algorithm}
\caption{\proc{Walk-MitM}}
\begin{codebox}
\Procname{$\proc{Walk-MitM}(G, u, v, \id{foundPaths})$}
\li $\id{visited} \gets \const{Empty-Set}$
\li $\proc{Recursive-Walk-Forward}(G, \attrib{G}{vertices}[u], 0, u, \id{visited})$
\li $\proc{Recursive-Walk-Backward}(G, \attrib{G}{vertices}[v], 0, "")$
\li \For $\id{node} \in \id{visited}$
\li \Do
      \For $\id{prefix} \in \attribii{node}{forwardPaths}, \id{suffix} \in \attribii{node}{backwardPaths}$,
\li   $\const{minDepth} \leqslant |\id{prefix}| + |\id{suffix}| \leqslant \const{maxDepth}$
\li   \Do
        $\attribii{foundPaths}{add}(\id{prefix} + \id{suffix})$
      \End
    \End
\end{codebox}
\begin{codebox}
\Procname{$\proc{Recursive-Walk-Forward}(G, u, \id{depth}, \id{pathString}, \id{visited})$}
\li \If $2 \cdot \id{depth} > \const{maxDepth} + 1$
\li \Then
      \Return
    \End
\li $\attribii{visited}{add}(\id{u})$
\li $\attribb{u}{forwardPaths}{add}(\id{pathString})$
\li \For $(u, u') \in \attrib{G}{edges}$
\li   \Do
      $\id{newPathString} \gets \id{pathString} + \attribe{u}{u'}{symbol}$
\li   $\proc{Recursive-Walk-Forward}(G, u', \id{depth} + 1, \id{newPathString}, \id{foundPaths})$
      \End
\end{codebox}
\begin{codebox}
\Procname{$\proc{Recursive-Walk-Backward}(G, u, v, \id{depth}, \id{pathString})$}
\li \If $2 \cdot \id{depth} > \const{maxDepth}$
\li \Then
      \Return
    \End
\li $\attribb{u}{backwardPaths}{add}(\id{pathString})$
\li \For $(u', u) \in \attrib{G}{edges}$
\li   \Do
      $\id{newPathString} \gets \id{pathString} + \attribe{u'}{u}{symbol}$
\li   $\proc{Recursive-Walk-Backward}(G, u', \id{depth} + 1, \id{newPathString}, \id{foundPaths})$
      \End
\end{codebox} 
\end{algorithm}

%\subsection{Эвристики устранения неопределенностей}

%К сожалению, одной паре чтений может соответствовать несколько различных путей, даже если эта пара
%соответствует уникальному фрагменту. Для устранения неопределенностей такого рода воспользуемся
%следующим наблюдением: 

\subsection{Исправление ошибок чтения}

Модифицировав данный алгоритм, можно получить эффективный метод устранения ошибочных чтений. 

Рассмотрим исходную последовательность ДНК: в ней каждая подстрока длины $k$ перекрывается как минимум $m - k$
фрагментами (кроме близких к краям), см. \figurename\ref{pic1}.

\begin{figure}[h]
\center{
\includegraphics{pic/pic1.svg.eps}
}
\caption{}
\label{pic1}
\end{figure}

Посчитаем для каждой вершины графа, сколько раз через нее проходят пути, найденные алгоритмом. После
этого, будем считать ошибочными все чтения, соответствующие вершинам с числом путей, не превосходящим
заданный порог.

Для подсчета путей, проходящих через вершины, модифицируем алгоритм 1, получив алгоритм 3.

\begin{algorithm}
\caption{\proc{Walk2}}
\begin{codebox}
\Procname{$\proc{Walk2}(G, u, v, \id{foundPaths})$}
\li \Return $\proc{Recursive-Walk2}(G, \attrib{G}{vertices}[u], \attrib{G}{vertices}[v], 0, u, \id{foundPaths})$
\end{codebox}
\begin{codebox}
\Procname{$\proc{Recursive-Walk2}(G, u, v, \id{depth}, \id{pathString}, \id{foundPaths})$}
\li \If $\id{depth} > \const{maxDepth}$
\li \Then
      \Return 0
    \End
\li $\id{paths} \gets 0$
\li \If $u \isequal v$ and $\id{depth} \geqslant \const{minDepth}$
\li \Then
      \attribii{foundPaths}{add}(\id{pathString})
\li   $\id{paths} \gets \id{paths} + 1$
    \End
\li \For $(u, u') \in \attrib{G}{edges}$
\li \Do
      $\id{newPathString} \gets \id{pathString} + \attribe{u}{u'}{symbol}$
\li   $\id{paths} \gets \id{paths} + \proc{Recursive-Walk2}(G, u', v, \id{depth} + 1, \id{newPathString}, \id{foundPaths})$
    \End
\li $\attrib{u}{paths} \gets \attrib{u}{paths} + \id{paths}$
\li \Return \id{paths}
\end{codebox}
\end{algorithm}

Можно пойти еще дальше, для каждой вершины построив матрицу $A$, такую
что $A_{ij}$ соответствует количеству путей, входящих в вершину по
$i$-ому ребру и выходящих по $j$-ому. Тогда можно идентифицировать и
разделить склеевшиеся по этой вершине последовательности:

\begin{figure}[h]
\center{
\includegraphics[width=500pt]{pic/unmerge.eps}
}
\caption{}
\end{figure}

\subsection{Сжатый граф де Брейна}

В случае если ошибок чтения немного и $k$ выбрано достаточно большим,
большая часть вершин в графе де Брейна имеет ровно одно входящее и
одно исходящее ребро. цепочки таких вершин можно сжать, заменив их
ребрами с целыми последовательностями вместо отдельных оснований.

В сжатом виде граф занимает меньше места в памяти, кроме того на нем
быстрее работают алгоритмы восстановления последовательностей.

\subsection{Оптимизации}

Для алгоритма исправления ошибок нужна только информация о том, по
каким ребрам может проходить восстановленная последовательность,
поэтому нет смысла дважды рассматривать в рекурсивном обходе одну и ту
же вершину, если по дороге в нее мы прошли одно и то же расстояние.

Более формально, рекурсивный обход можно заменить на метод
динамического программирования по состояниям (вершина, расстояние до
стартовой вершины). Таким образом сложность алгоритма уменьшается с
экспоненциальной до линейной от размера графа.

Кроме того, можно заметить что нет смысла рассматривать состояние если
кратчайшее расстояние до конечной вершины + уже пройденное превосходит
искомую длину пути.

Асимтотически эта оптимизация ничего не дает, но на практике
отсекается более $3/4$ состояний

\section{Общая схема системы}

Общая схема решения состоит в следующем:

\begin{enumerate}
\item Построить граф де Брейна
\item Построить его сжатую форму
\item Сделать одну или несколько итераций алгоритма исправления ошибок
  и разделения склеившихся путей
\item Последовательности на ребрах получившегося графа считать результирующими контигами
\end{enumerate}

\section{Масштабируемость системы}

Все этапы алгоритма поддается почти линейному масштабированию на распределенные системы.

Рассмотрим схему такой распределенной системы:
\begin{enumerate}
\item Построить граф де Брейна в распределенной хеш-таблице.
\item Сжать его, при этом каждая ребро можно строить независимо.
\item Сжатый граф раздать нодам и выполнить алгоритм восстановления
  путей независимо для всех пар.
\item Собрать полученную информацию о количестве прохождений по ребрам
  и сделать коррекцию графа.
\item Вернуть последовательности на ребрах графа в качестве результирующих контигов
\end{enumerate}

\section{Выводы по главе \protect\ref{chapter3}}

Разработан алгоритм для сборки и схема его масштабирования.

